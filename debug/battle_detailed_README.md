# 对战调试工具 Debug Tools

这个文件夹包含用于调试神经网络和决策树对战的详细工具。

## 📁 文件说明

- `battle_detailed.py` - 详细对战日志工具，输出每一步的完整信息

## 🎯 battle_detailed.py - 详细对战调试工具

### 功能特性

输出完整的对局记录，包括每一步的：
- ✅ 原始棋盘状态（数组和可视化）
- ✅ 当前玩家ID和是否需要视角转换
- ✅ 转换后的输入（如果进行了视角转换）
- ✅ 合法动作列表
- ✅ 模型的预测动作
- ✅ 动作是否合法
- ✅ 执行后的棋盘状态
- ✅ 游戏结束原因（获胜/平局/非法移动）
- ✅ 支持随机探索以测试不同对局场景

### 使用方法

#### 基本用法

```bash
cd /path/to/viper-verifiable-rl-impl
python debug/battle_detailed.py [选项]
```

#### 命令行参数

| 参数 | 类型 | 默认值 | 说明 |
|------|------|--------|------|
| `--oracle-path` | str | `log/oracle_TicTacToe-v0.zip` | 神经网络模型路径 |
| `--viper-path` | str | `log/viper_TicTacToe-v0_all-leaves_10.joblib` | 决策树模型路径 |
| `--mode` | str | `nn-vs-tree` | 对战模式（见下表） |
| `--n-games` | int | `1` | 对战局数 |
| `--epsilon` | float | `0.0` | 随机探索概率 (0.0-1.0) |
| `--seed` | int | `None` | 随机种子，用于复现结果 |

**对战模式 (--mode)：**
- `nn-vs-tree`: 神经网络先手 (X) vs 决策树后手 (O)
- `tree-vs-nn`: 决策树先手 (X) vs 神经网络后手 (O)
- `both`: 两种模式都运行

**随机探索概率 (--epsilon)：**
- `0.0`: 完全确定性策略，用于验证是否每次都走相同的棋
- `0.1-0.3`: 轻度随机性，大部分时候用策略，偶尔随机
- `0.5+`: 高度随机性

### 使用场景示例

#### 场景1：验证确定性问题

检查模型是否每次都走相同的棋（导致重复出现相同错误）：

```bash
# 运行3次，使用相同的随机种子
python debug/battle_detailed.py --mode nn-vs-tree --n-games 1 --epsilon 0.0 --seed 42
python debug/battle_detailed.py --mode nn-vs-tree --n-games 1 --epsilon 0.0 --seed 42
python debug/battle_detailed.py --mode nn-vs-tree --n-games 1 --epsilon 0.0 --seed 42
```

**期望结果：** 三次运行应该产生完全相同的对局过程。

#### 场景2：调试非法移动问题

查看第一步非法移动的详细信息：

```bash
python debug/battle_detailed.py --mode nn-vs-tree --n-games 1 --epsilon 0.0
```

**输出分析重点：**
- 检查决策树作为O玩家时的视角转换是否正确
- 查看预测的动作是否在合法动作列表中
- 确认转换后的输入是否符合预期

#### 场景3：加入随机性测试

测试加入随机探索后能否避免非法移动：

```bash
# 10% 随机探索，运行5局
python debug/battle_detailed.py --mode nn-vs-tree --n-games 5 --epsilon 0.1

# 30% 随机探索，运行10局
python debug/battle_detailed.py --mode both --n-games 10 --epsilon 0.3
```

**分析目标：**
- 统计非法移动发生的频率
- 确定是否只在特定局面下出现非法移动
- 验证随机性能否避开问题状态

#### 场景4：对比两种先后手情况

```bash
python debug/battle_detailed.py --mode both --n-games 1 --epsilon 0.0
```

**对比重点：**
- 神经网络作为X vs O时的表现差异
- 决策树作为X vs O时的表现差异
- 视角转换的正确性

#### 场景5：可复现的随机测试

需要分享调试结果时，使用固定种子确保他人能复现：

```bash
python debug/battle_detailed.py --mode both --n-games 5 --epsilon 0.2 --seed 12345
```

### 输出示例

```
================================================================================
游戏 1/1: 神经网络 (X) vs 决策树 (O)
================================================================================

初始棋盘:
  . | . | .
 -----------
  . | . | .
 -----------
  . | . | .

────────────────────────────────────────────────────────────────────────────────
第 1 步
────────────────────────────────────────────────────────────────────────────────

当前玩家: 神经网络 (X) (player_id=1)
当前棋盘状态: .........
当前棋盘数组: [0. 0. 0. 0. 0. 0. 0. 0. 0.]
合法动作: [0 1 2 3 4 5 6 7 8]
视角转换: NO (因为是X玩家)
输入 = 原始棋盘

[NN DEBUG 1]
  玩家ID: 1
  原始棋盘: [0. 0. 0. 0. 0. 0. 0. 0. 0.]
  预测动作: 4, 类型: <class 'numpy.int64'>
  合法动作: [0 1 2 3 4 5 6 7 8]
  动作是否合法: True
[神经网络] 预测动作: 4
动作 4 是否合法: True

执行后棋盘:
  . | . | .
 -----------
  . | X | .
 -----------
  . | . | .

────────────────────────────────────────────────────────────────────────────────
第 2 步
────────────────────────────────────────────────────────────────────────────────

当前玩家: 决策树 (O) (player_id=-1)
当前棋盘状态: ....X....
当前棋盘数组: [ 0.  0.  0.  0.  1.  0.  0.  0.  0.]
合法动作: [0 1 2 3 5 6 7 8]
视角转换: YES (因为是O玩家)
转换后输入: ....O....
转换后数组: [-0. -0. -0. -0. -1. -0. -0. -0. -0.]

[TREE DEBUG 1]
  玩家ID: -1
  原始棋盘: [ 0.  0.  0.  0.  1.  0.  0.  0.  0.]
  转换后棋盘: [-0. -0. -0. -0. -1. -0. -0. -0. -0.]
  预测动作: 4, 类型: <class 'numpy.int64'>
  合法动作: [0 1 2 3 5 6 7 8]
  动作是否合法: False
[决策树] 预测动作: 4
动作 4 是否合法: False

⚠️  非法移动！位置 4 已被占用或超出范围
   当前位置值: 1.0

执行后棋盘:
  . | . | .
 -----------
  . | X | .
 -----------
  . | . | .

================================================================================
游戏结束!
================================================================================
❌ 决策树 (O) 非法移动，输掉游戏！
   非法动作: 4
   该位置状态: 1.0
奖励: -10
```

### 调试技巧

1. **定位非法移动原因**
   - 查看"转换后数组"是否正确
   - 确认"合法动作"列表是否包含预测动作
   - 检查视角转换逻辑

2. **对比不同场景**
   - 使用 `--mode both` 对比先后手
   - 使用相同 `--seed` 确保可复现

3. **使用随机探索**
   - 从低概率开始 (0.1)
   - 逐步增加观察变化
   - 统计非法移动频率

4. **保存输出**
   ```bash
   python debug/battle_detailed.py --mode both --n-games 5 > output.log 2>&1
   ```

## 🔍 常见问题排查

### 问题1: 决策树总是产生非法移动

**可能原因：**
- 视角转换未正确应用
- 决策树训练数据不包含后手场景
- 决策树预测的动作索引有问题

**排查步骤：**
1. 运行 `python debug/battle_detailed.py --mode tree-vs-nn --n-games 1`
2. 检查输出中"转换后数组"的值
3. 确认决策树作为X（先手）时是否正常

### 问题2: 神经网络和决策树对战总是相同结果

**可能原因：**
- 策略完全确定性
- 没有使用随机探索

**解决方案：**
```bash
python debug/battle_detailed.py --mode both --n-games 10 --epsilon 0.2
```

### 问题3: 无法复现问题

**解决方案：**
使用固定随机种子：
```bash
python debug/battle_detailed.py --mode both --n-games 5 --seed 42
```

## 📊 统计非法移动

如果需要批量测试并统计非法移动，可以结合其他工具：

```bash
# 运行100局并统计
for i in {1..100}; do
  python debug/battle_detailed.py --mode nn-vs-tree --n-games 1 --epsilon 0.0 --seed $i
done | grep "非法移动" | wc -l
```

## 🔗 相关文件

- `../battle_nn_vs_tree.py` - 批量对战工具
- `../gym_env/tictactoe.py` - 井字棋环境实现
- `../gym_env/tictactoe_selfplay.py` - 自我对弈环境

## 💡 贡献者提示

在修改对战逻辑或视角转换逻辑后，务必运行此工具验证：

```bash
# 基本验证
python debug/battle_detailed.py --mode both --n-games 1 --epsilon 0.0 --seed 42

# 压力测试
python debug/battle_detailed.py --mode both --n-games 20 --epsilon 0.3
```
